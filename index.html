<html>
    <head>
        <title>Storytelling project</title>
        <script src="d3.js"></script>
            <link rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'>
            <script src='https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js'></script>
            <script src='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js'></script>
            <style>
                * {
                    font-family: "Times New Roman", Times, serif;
                    font-size: 20px;
                    text-align: justify;
                }

                #tooltip{
                    position: absolute;
                    display: none;
                    line-height: 1;
                    padding: 5px;
                    background: rgba(0, 0, 0, 0.8);
                    color: #fff;
                    border-radius: 2px;
                }

            </style>
    </head>
    <body>
        <div id='tooltip'></div>
        <div class='container'>
            <div class='row'>
                <h1> IMDB MOVIE DATASET ANALYSIS </h1>
            </div>
            <div class='row'>
                <p>  The IMDB dataset is fascinating because it is allowing us to observe some general trends about movies. A movie's performance depends on a plethora of factors, and we will observe a few of them today. First, we observed that it's not just the content of the movie, but also its origins that affect its rating. As shown below, we can see that movies from some parts of the world
                and some languages do better than others.</p>
            </div>
            <div class='row'>
                <div class='col-md-5'>
                    <p> Shown on the right is a choloropleth map showing how the IMDB score varies by countries. </p>
                </div>
                <div class='col-md-7'>
                    <svg = id='scoreVsCountry'></svg>
                </div>   
            </div>
            <div class='row'>  
                <div class='col-md-5'>
                    <p> Here, we have visualized the countries based on the amount of money their movies have made (in millions). </p>
                </div>
                <div class='col-md-7'> 
                    <svg = id='grossVsCountry'></svg>
                </div>
            </div>
            <div class='row'>  
                <div class='col-md-5'>
                    <p> Here, we visualized the countries based on the average number of voters for each of the movies. </p>
                </div>
                <div class='col-md-7'> 
                    <svg = id='numUsersVsCountry'></svg>
                </div>
            </div>
            <div class='row'>  
                <div class='col-md-5'>
                    <p> Finally, we visualized the countries based on the average number of facebook likes its movies recieves. </p>
                </div>
                <div class='col-md-7'> 
                    <svg = id='facebookLikesVsCountry'></svg>
                </div>
            </div>
            <div class = 'row'>
                <p> Now, let's look at how the language of a movie impacts its rating...</p>
            </div>
            <div class='row'>
                <div class='col-md-12'>
                    <svg id = 'languageByRating'></svg>
                </div>                
            </div>
            <div class = 'row'>
                <p> It's clear that movies in some languages, like Telugu and Polish, were rated better than movies in other languages. </p>
            </div>

            <div class = 'row'>
                <p> People mostly say that movies made in the olden days were better than the ones made today. We observed this hypothesis and concluded that the hypothesis holds true, based on the ratings of movies based on their release date, as shown below </p>
            </div>
            <div class='row'>
                <svg id='ratingVsTime'></svg>
            </div>

            <div class = 'row'>
                <p> Since how well a movie is made depends a lot on directors, let's look at some of the best directors out there, based on how hit their movies were and how well their movies are rated. </p>
            </div>
            <div class='row'>
                <div class='col-md-6'>
                    <svg id ='directorByRating'></svg>
                </div>
                <div class='col-md-6'>
                    <svg id ='directorByHit'></svg>
                </div>
            </div>
            <div class = 'row'>
                <p> Speaking of quality, we would like to see if spending more money on a movie equates to better ratings. We would also like to see if the amount of money a movie makes has any relation with its quality. Based on the visualizations shown below, its clear that the rating of a movie is positively correlated to the money spent on it. This indicates that the more money a film maker spends on a movie, more the chances are that it would be rated well and inferentially, better would be its box office collections.  </p>
            </div>
            <div class='row'>
                <div class='col-md-6'>
                    <svg id='scoreVsbudget'></svg>
                </div>
                <div class='col-md-6'>
                    <svg id='scoreVsGross'></svg>
                </div>
            </div>
        </div>
    </body>
    <script>

    let movieData = {};

    function loadData() {
        return Promise.all([
            d3.csv("movie_metadata.csv"),
            d3.json("contries.geo.json"),
        ]).then(datasets => {
            movieData.all = datasets[0];
            movieData.imdb_score_country = fixData(getGrouped(datasets[0],{groupBy:'country',groupQuantity:'imdb_score'}),{});
            movieData.gross = fixData(getGrouped(datasets[0],{groupBy:'country',groupQuantity:'gross'}),{scale:0.000001,smooth:1000});
            movieData.num_voted_users = fixData(getGrouped(datasets[0],{groupBy:'country',groupQuantity:'num_voted_users'}), {});
            movieData.movie_facebook_likes = fixData(getGrouped(datasets[0],{groupBy:'country',groupQuantity:'movie_facebook_likes'}), {});
            movieData.language = fixData(getGrouped(datasets[0],{groupBy:'language',groupQuantity:'imdb_score'}),{order:'descending'});
            movieData.director = fixData(getGrouped(datasets[0],{groupBy:'director_name',groupQuantity:'imdb_score'}),{order:'descending',limit:40});
            movieData.title_year = fixData(getGrouped(datasets[0],{groupBy:'title_year',groupQuantity:'imdb_score'}),{order:'descending'});   
            movieData.hitRatioDir = fixData(getGrouped(datasets[0],{groupBy:'director_name',groupQuantity:'gross',gq2:'budget'}),{order:'descending',limit:40,scale:0.000001});
            movieData.geoJSON = datasets[1];
            return movieData;
        })
    }

    function getGrouped(data, params){

        var grouped = d3.nest()
            .key(function(d) { return d[params.groupBy]; })
            .key(function(d){return d[params.groupBy2];} )
            .rollup(function(d){

                return d3.mean(d,function(x){
                    if(params.gq2 == undefined){mul = 0;}
                    return x[params.groupQuantity] - mul;})
            })
            .entries(data);
        return grouped;
    }

    function fixData(data, params){

        if(params.scale == undefined){params.scale = 1;}
        if(params.smooth == undefined){params.smooth = 0;}
        if(params.order == undefined){params.order = 'ascending';}
        if(params.limit == undefined){params.limit = data.length;}

        for(var i = 0; i<data.length; i++){
            data[i].value = (data[i].value + params.smooth) * params.scale;
        }

        data = data.filter(function(d){ return d.value != 0 && d.key != "";});
        return data.sort(function(a,b){
            if(params.order == 'descending'){
                return d3.descending(a.value,b.value);
            }
            return d3.ascending(a.value,b.value);
        }).slice(0, params.limit);;

    }

    function showData() {
      drawMap(movieData.geoJSON,'scoreVsCountry', movieData.imdb_score_country, 'blue');
      drawMap(movieData.geoJSON,'grossVsCountry', movieData.gross, 'green');
      drawMap(movieData.geoJSON,'numUsersVsCountry', movieData.num_voted_users, 'red');
      drawMap(movieData.geoJSON,'facebookLikesVsCountry', movieData.movie_facebook_likes, 'purple');
      drawBarChart(movieData.language,'languageByRating',0.85);
      drawBarChart(movieData.director,'directorByRating',0.45);
      drawBarChart(movieData.hitRatioDir,'directorByHit',0.45);
      drawLineChart(movieData.title_year, 'ratingVsTime');
      drawScatterPlot(movieData.all,'scoreVsbudget',['imdb_score','budget'],{color:'red',title:'BUDGET VS IMDB SCORE'});
      drawScatterPlot(movieData.all,'scoreVsGross',['imdb_score','gross'],{color:'green',title:'GROSS AMOUNT VS IMDB SCORE'});
    }

    

    function getMapConfig(id){
      let width = 600;
      let height = 400;
      let container = d3.select(id).attr('width',width).attr('height',height); 
      return {width, height, container}
    }

    function getMapProjection(config) {
      let {width, height} = config;
      let projection = d3.geoMercator();
      projection.scale(100).translate([width/2, height / 1.5 ])           
      movieData.mapProjection = projection;
      return projection;
    }

    function drawBaseMap(container, countries, projection,type, feature, color){

        var min = feature[0].value; 
        var max = feature[feature.length - 1].value;

        switch(color){
            case 'red': interpolator = d3.interpolateReds;  ;break;
            case 'green': interpolator = d3.interpolateGreens; break;
            case 'blue': interpolator = d3.interpolateBlues; break;
            case 'purple': interpolator = d3.interpolatePurples; break;
        }
        let shade = d3.scaleSequential().domain([min,max]).interpolator(interpolator);
        let path = d3.geoPath().projection(projection);

        container.selectAll('path').data(countries)
            .enter().append('path')
            .attr('d',path)
            .attr("stroke", 'white')
            .attr('fill', function(d){
                for(var i = 0; i< feature.length; i++){
                    if(feature[i].key === d.properties.name){
                        return shade(Math.floor(feature[i].value));    
                    }      
                } 
            })
            .on('mouseenter', function(d){
                for(var i = 0; i< feature.length; i++){
                    if(feature[i].key === d.properties.name){
                        showToolTip([feature[i].key, feature[i].value.toFixed(2)],[d3.event.pageX, d3.event.pageY])   
                    }      
                }                
                
            })
            .on('mouseleave', (d) => d3.select('#tooltip').style('display','none').style('z-index','0'));
    }

    function drawMap(geoJeon, id, data, color) {
      let mapConfig = getMapConfig('#'+id);
      let projection = getMapProjection(mapConfig);
      drawBaseMap(mapConfig.container, geoJeon.features, projection, id, data, color);
    }

    loadData().then(showData);


    function drawBarChart(data,id,widthWeight) {

        margin = {top: 50, right: 50, bottom: 150, left: 50},
        width = widthWeight*window.innerWidth - margin.left - margin.right,
        height = 600 - margin.top - margin.bottom; 

        var svg = d3.select('#'+id).attr('width',width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform',"translate("+margin.left+","+margin.top+")");

        var xScale = d3.scaleBand().domain(data.map(function(d){return d.key;})).range([0,width]);
        var min = data[0].value; 
        var max = data[data.length - 1].value;
        var yScale = d3.scalePow().exponent(2).domain([0, data[0].value]).range([height,0]);
        let shade = d3.scaleSequential().domain([min,max]).interpolator(d3.interpolateCool);

        svg.selectAll('.bar')
            .data(data)
            .enter().append('rect')
            .attr('class','bar')
            .attr('x', function(d){return xScale(d.key);})
            .attr('width',xScale.bandwidth() - 5)
            .attr('y',function(d){return yScale(d.value);})
            .attr('height',function(d){return height - yScale(d.value);})
            .style("margin-left",function(d){return '10px';})
            .style('fill',function(d){return shade(d.value);})
            .on('mouseenter', (d) => showToolTip([d.key, d.value.toFixed(2)],[d3.event.pageX, d3.event.pageY]))
            .on('mouseleave', (d) => d3.select('#tooltip').style('display','none').style('z-index','2'));

        svg.append('g').attr('transform',"translate(0,"+height+")").call(d3.axisBottom(xScale)).selectAll("text")
            .attr("x", 0)
            .attr("dy", ".35em")
            .attr("transform", "rotate(75)")
            .style("text-anchor", "start")
            .attr('font-size','5px')
            .attr('font-size','4px'); 
        svg.append('g').call(d3.axisLeft(yScale));
          
    }

    function drawLineChart(data,id){

        margin = {top: 50, right: 50, bottom: 100, left: 50},
        width = 0.85*window.innerWidth - margin.left - margin.right,
        height = 600 - margin.top - margin.bottom; 

        var parseTime = d3.timeParse("%Y");

        data.forEach(function(d){
            d.key = parseTime(+d.key);
        });

        var max = data[0].value;

        data = data.sort(function(a,b){
            return d3.ascending(a.key,b.key);
        });


        var svg = d3.select('#'+id).attr('width',width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform',"translate("+margin.left+","+margin.top+")");


        var xScale = d3.scaleTime().domain(d3.extent(data,function(d){return d.key;})).range([0,width]);

        var yScale = d3.scaleLinear().domain([0, max]).range([height,0]);

        var valueline = d3.line()
            .x(function(d) { return xScale(d.key); })
            .y(function(d) { return yScale(d.value); })
            .curve(d3.curveMonotoneX);

        svg.append('path')
          .attr('class', 'line')
          .datum(data)
          .attr('d', valueline)
          .style('fill','none')
          .style('stroke','blue');

        svg.selectAll('.dot')
            .data(data)
            .enter().append('circle') 
            .attr('class', 'dot') 
            .attr('cx', function(d) { return xScale(d.key) })
            .attr('cy', function(d) { return yScale(d.value) })
            .attr("r", 2)
            .style('fill','none')
            .style('stroke','blue')
            .on('mouseenter', (d) => showToolTip([d.key.getFullYear(), d.value.toFixed(2)],[d3.event.pageX, d3.event.pageY]))
            .on('mouseleave', (d) => d3.select('#tooltip').style('display','none').style('z-index','2'));

        svg.append('g').attr('transform',"translate(0,"+height+")")
            .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat("%Y")))
            .selectAll("text")
            .attr("x", 0)
            .attr("dy", ".35em")
            .attr("transform", "rotate(75)")
            .style("text-anchor", "start")
            .attr('font-size','2px'); 

        svg.append('g').call(d3.axisLeft(yScale));
    }

    function drawScatterPlot(data,id,keys,params){

        switch(params.color){
            case 'red': clr = 'red'; break;
            case 'green': clr = 'green'; break;
        }

        margin = {top: 50, right: 50, bottom: 100, left: 50},
        width = 0.45*window.innerWidth - margin.left - margin.right,
        height = 600 - margin.top - margin.bottom; 

        var svg = d3.select('#'+id).attr('width',width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform',"translate("+margin.left+","+margin.top+")");

        var xScale = d3.scaleLinear().domain([0,600]).range([0,width]);
        var yScale = d3.scaleLinear().domain([0, 10]).range([height,0]);

        svg.selectAll('.dot')
            .data(data)
            .enter().append('circle') 
            .attr('class', 'dot') 
            .attr('cx', function(d) { return xScale(d[keys[1]]/1000000); })
            .attr('cy', function(d) { return yScale(d[keys[0]]); })
            .attr("r", 1.5)
            .style('fill','none')
            .style('stroke', clr)

        svg.append('g').attr('transform',"translate(0,"+height+")")
            .call(d3.axisBottom(xScale))
            .selectAll("text")
            .attr("x", 0)
            .attr("dy", ".35em")
            .attr("transform", "rotate(75)")
            .style("text-anchor", "start")
            .attr('font-size','2px'); 

        svg.append('g').call(d3.axisLeft(yScale));  

        svg.append('text')
        .attr('x', (width / 2))             
        .attr('y', 0 - (margin.top / 2))
        .attr('text-anchor', 'middle')  
        .text(params.title);      
    }


    function showToolTip(value, coordinates){
        d3.select('#tooltip')
            .html("<p><strong>"+value[0]+"</strong></p><p>"+value[1]+"</p>")
            .style('top', coordinates[1] +'px')
            .style('left',coordinates[0]+'px')
            .style('display','block')
            .style('z-index','2')
            .style('cursor','pointer')
            .style('pointer-events','none');
    }

    function load(viz){
        switch(viz){
            case 'budgetLine': loadData().then(loadBudgetLine); break;
        }
        
    }

    function loadBudgetLine(){

    }


    </script>
</html>